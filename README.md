# Exp_robotics_lab Assignment2
## INTROCUCTION
Purpose of this repository is to develop the assignment 2 of Experimental Robotics Laboratory. In this assignment robot moves between four position and oracle position in the gazebo simulation. There are markers in that four position, whenever robot place the cluedo link of its arm, the hint is generated. The generated hint is checked for consistency and complete hypothesis. If it is a complete and consistent hypothesis robot moves to the oracle position to check for the solution. If the solution is correct the game ends or otherwise it go to the other points to collect hints.

## SOFTWARE ARCHITECTURE
In order to better understand the software architecture we can utilise the UML component diagram

![CLUEDO_SIM](https://user-images.githubusercontent.com/82164428/220006145-f78bf9fe-5464-4f06-bde2-0c75e81ae07f.jpg)

The ontology_interface node which receives the solution and hint from the simulation node. The simulation node. Reset planner is the node which gives all the information to the ROSplan kowledge with the help of planner class about the PDDL problem. ROSplan with the aid of PDDL generate a plan and dispatch the plan to the action interface. 

The actions which are defined in the domain of PDDL are go_to_waypoint, movearm, update_ontology and check_consistency. go_to_waypoint sends the goal to reach to the go_to_point node(i.e marker coordinates posistion in the map). go_to_point moves the robot from intial to the goal position. Once it reaches the goal the move_arm node is initiated to move the robotic arm to the marker position.

Ontology_interface update the hints to the ontology when update_request node request. Ontology perform consistency check when the check_consistency node request. With the help of Armor service all the ontology operations are performed with the help of myArmor class. When the solution is found ontology_interface sends the true message to reset planner to stop. Go to point sends and receives the velocity and odometry from gazebo respectively. 

Now to the ros workspace, there are two directories in the workspace, one is a moveit config generated by move it setup assistant and the erl2 directories contains all the necessaty things to simulate and run the simulation.

### Moveit_cofig:
Has all the configuration files generated by the moveit setup assistant. And the troubleshooting steps are performed in order to run the simulation and the pacakges. Only to position are defined in the assistant, one is the initial normal position and the other one is to reach the marker position which is target position.

### erl2:
### Scripts:
### Ontology.py:
   This node recieves the hint from the /oracle_hint service and add them. And it checks the received hint is whether consistent and complete. When the recieved solution is consistent and complete it checks with the solution ID from the /oracle_solution service otherwise removes them from the onotology. If the solution is correct it tries to finish the game or else it sends the resetrequest with the false parameter. And also peforms query operation based on the request. 

### go_to_point.py:
 This node implement the movement of the robot as well orient itself to the goal postion. Based on the goal received from the gotowaypoint node via ActionGoal the robot aligns to the direction set the desired velocity and move towards the target and reach the target postion. 

### reset_planner.py:
   This is the node which calls the rosplan_knowledge_base service with the palanner class methods. And it checks the solution whether the solution is concluded or not with the /reset_planning message. Based on the solution is correct or not the problem is defined again and the process continues.


 ### myArmor class:
 This is the class method to communicate with the Armor service. It is based on the message format to be communicated with the Armor service.
 
 ### plaber class:
 THis is the class to communicate with the ROSplan.
 
 ### src:
 ### init.cpp:
 Move the robotic arm to the initial postion defined in the move it.
 
 ### checkconsistency.cpp:
 This node implements the ROSPlan CheckConsistencyActionInterface: the corresponding behaviour for the check_consistency action in the PDDl file
 
 ### gotoWaypoint.cpp:
 This node implements the ROSPlan GoToWaypointActionInterface: the corresponding behaviour for the go_to_waypoint action in the PDDl file.
 
 ### movearm.cpp:
 This node implements the ROSPlan MovearmActionInterface: the corresponding behaviour for the movearm action in the PDDl file.
 
 ### update_ontology.cpp:
 This node implements the ROSPlan UpdateOntologyActionInterface: the corresponding behaviour for the update_ontology action in the PDDl file.
 
 ### simulation.cpp:
 Node for generating the hints when a marker is reached with the arm.
 
 ### URDF:
 This folder all the descriptions of the robot also has the URDF generated by the move it.
 
 ### WORLD:
 Contains the description for the simulation
 
 ### PDDL:
 This folder has the domain and the problem file of the PDDL.
 
 The action, srv and msg folder all the custom messages for action, service and messages respectively.
 
 Launch folder has the assignment.launch to launch the simulation. Planner.launch to launch the planner and the nodes.launch all the nodes to effectively run the simulation.
 
 Config folder has the rviz configuration and all the motor configurations.
 
 The cluedo_onotolg.owl initial scene setup. And the simulation.sh for launching the simulation with the aid of genome terminal. 
 
 ### OTHER PACKAGES
 
ARMOR SERVICE (More details in https://github.com/EmaroLab/armor)

ROSPlan (More details in https://github.com/KCL-Planning/ROSPlan)

Moveit (older version)

 
The temporal diagram of the architecture to better understand flow of the architecure.

![CLUEDO_SIM_TEMP](https://user-images.githubusercontent.com/82164428/220012696-da5d7690-7667-4c02-9020-ba02fe139ba6.jpg)



## INSTALLATION AND RUNNING:
In order to run the simulation clone this repostitory into your workspace. If you are running on the docker machine of the course no need to clone other packages. Otherwise clone all the packages to the workspace.

 ```
 git clone https://github.com/SKSUB/Exp_robotics_lab_2
 ```

After cloning usual procedures of building the package, and install the dependencies based on the error.
```
catkin_make
```
In order to start the simulation:
```
./simulation.sh
```
It starts all the necessry nodes to simulate the simulation of the game. 

Following are the pictures of the simulation

![Screenshot 2023-02-20 041910](https://user-images.githubusercontent.com/82164428/220013976-1286484a-1ed5-4cb9-975a-29722151fa0e.png)

The picture above shows the simulation of the gazebo and the move it planner ready to control the robot.

![Screenshot 2023-02-20 041621](https://user-images.githubusercontent.com/82164428/220014068-5e64cce5-932f-4ec7-80a5-77a694dbd014.png)

Above pictures shows the robot in the initial position and the planner ready to dispatch.

And to better understand all the nodes of the simulation, rqt graph showing all the nodes and its connections.

![Screenshot 2023-02-20 041116](https://user-images.githubusercontent.com/82164428/220014302-f160ac4f-b6cb-4456-9c0b-1a9bdfbedb14.png)


## SYSTEM WORKING AND LIMITATIONS
System works in the flow, first it generates the plan, and proceed with the plan and then when the solution is reached it ends the game or it move back to generation of th plan and starts again. 

There are many limitations in the system, first probably it is time consuming simulation process. Because it has gnerate the plan based on the problem. Then it proceed with the plan. And then the received hints are queried and if the solution id not foudn it has to repeat the whole structure. The next problem involved with the simulation is it has numerous nodes running side by side to support each other. Any miss firing of the nodes to failure of the simulation. And robot moves at the snail speed even with the fast configuration settings (with low power processot it takes ages to complete)

In order to overcome the limits the plan is genrated and the solution is reached, if the solution is not reach it is a good idea to repeat the same plan unless the plan is failed rather than goind from the start.

### CONTACTS
SATHISH KUMAR SUBRAMANI.
ROBOTICS ENGINEER, UNIGE.
4847560@studenti.unige.it

